"""
配置文件 - SegFormer变化检测
"""
import os
from pathlib import Path
import torch


class Config:
    """变化检测训练和评估配置"""

    # ==================== Task ====================
    # cd: Change Detection (binary)
    # scd: Snow Cover Days regression (0-181)
    TASK = "scd"

    # ==================== 路径配置 ====================
    PROJECT_ROOT = Path(__file__).parent.resolve()

    # 数据路径 - LEVIR-CD数据集
    DATA_ROOT = PROJECT_ROOT / "data/LEVIR-CD"
    TRAIN_DIR = DATA_ROOT / "train"
    VAL_DIR = DATA_ROOT / "val"
    TEST_DIR = DATA_ROOT / "test"

    # ==================== SCD data ====================
    # Patch index CSV produced by tools/filter_patches_no_overlap.py
    # Train can use 50% overlap (stride=patch/2), while val/test keep non-overlap for fair evaluation.
    SCD_PATCH_INDEX_TRAIN = PROJECT_ROOT / "data/patch_index/filter_patches_overlap50.csv"
    # For publishing / fixed evaluation splits (generated by tools/split_patch_index_by_winter.py):
    SCD_PATCH_INDEX_VAL = PROJECT_ROOT / "data/patch_index/scd_no_overlap_val.csv"
    SCD_PATCH_INDEX_TEST = PROJECT_ROOT / "data/patch_index/scd_no_overlap_test.csv"
    # Fallback when split-specific CSVs are not present:
    SCD_PATCH_INDEX_EVAL = PROJECT_ROOT / "data/patch_index/filter_patches_no_overlap.csv"

    # SCD label definition (computed from MODIS NDSI):
    # valid day: NDSI != 255
    # snow day: valid && NDSI >= threshold (NDSI is 0-100 scaled)
    SCD_MAX_DAYS = 181
    SCD_NDSI_THRESHOLD = 40

    # SCD input mode:
    # - "stats": per-pixel seasonal stats (fast, low-memory)
    # - "temporal": full 181-day ERA5 sequences + static (for TCN/Mamba temporal baselines)
    SCD_INPUT_MODE = "temporal"
    SCD_T = 181

    # Normalization for temporal inputs (after nodata masked to 0)
    # temp: Celsius, prcp: mm/day (or mm; depends on your export, but clipping still works)
    SCD_TEMP_CLIP = (-40.0, 20.0)
    SCD_PRCP_CLIP = (0.0, 50.0)

    # Split by winter "YYYY_YYYY" extracted from group_id.
    # Fixed split (15 winters total):
    # - train: first 11 winters (2010_2011 .. 2020_2021)
    # - val: next 2 winters (2021_2022, 2022_2023)
    # - test: last 2 winters (2023_2024, 2024_2025)
    SCD_VAL_WINTERS = ["2021_2022", "2022_2023"]
    SCD_TEST_WINTERS = ["2023_2024", "2024_2025"]

    # Input channels for SCD dataset
    # stats: 11 (temp mean/std/min/max + prcp sum/mean/max + 4 static)
    # temporal: 2*T + 4 (temp[181] + prcp[181] + 4 static)
    SCD_IN_CHANNELS = 11 if SCD_INPUT_MODE == "stats" else (2 * SCD_T + 4)

    # TemporalConv (TCN) baseline hyperparams
    SCD_TCN_CHANNELS = 32
    SCD_TCN_KERNELS = [5, 5, 3]
    # Downsample temporal length to reduce memory/compute (T=181 -> 91 -> 46).
    SCD_TCN_STRIDES = [2, 2, 1]
    SCD_TCN_DROPOUT = 0.1
    # Spatial pooling factor before TCN to avoid per-pixel TCN memory blowup.
    SCD_TCN_SPATIAL_POOL = 4

    # 输出路径
    OUTPUT_ROOT = PROJECT_ROOT / "outputs"
    CHECKPOINT_DIR = OUTPUT_ROOT / "checkpoints"
    LOG_DIR = OUTPUT_ROOT / "logs"
    VIS_DIR = OUTPUT_ROOT / "visualizations"
    RESULTS_DIR = OUTPUT_ROOT / "results"

    # 创建必要的目录
    for dir_path in [OUTPUT_ROOT, CHECKPOINT_DIR, LOG_DIR, VIS_DIR, RESULTS_DIR]:
        dir_path.mkdir(parents=True, exist_ok=True)

    # ==================== 数据配置 ====================
    # 原始图像尺寸
    ORIGINAL_SIZE = 1024

    # 训练图像尺寸（裁剪后）
    IMAGE_SIZE = 256

    # 类别数（二值变化检测：1通道输出，用Sigmoid）
    NUM_CLASSES = 1

    # Ignore标签
    IGNORE_INDEX = 255

    # 类别名称
    CLASS_NAMES = ['unchanged', 'changed']

    # 类别颜色（用于可视化）
    CLASS_COLORS = [
        [0, 0, 0],       # 黑色 - 无变化
        [255, 255, 255]  # 白色 - 有变化
    ]

    # ==================== 模型配置 ====================
    # SegFormer变体
    # scd models: segformer_tcn_b1 (baseline), segmamba_tiny (mamba)
    MODEL_TYPE = "segformer_tcn_b1"
    PRETRAINED = True  # 使用ImageNet预训练

    # 特征融合方式
    FUSION_TYPE = "diff"  # "diff", "concat", "attention"

    # 是否使用深度监督
    DEEP_SUPERVISION = True
    DEEP_SUPERVISION_WEIGHTS = [1.0, 0.4, 0.2, 0.1]  # 各尺度权重


    # ==================== 训练配置 ====================
    # 基础训练参数
    BATCH_SIZE = 8  # 4060 8G显存，256x256图像
    NUM_EPOCHS = 200  # 实验发现300 epochs优于200 epochs
    NUM_WORKERS = 2

    # 梯度累积（等效batch_size = BATCH_SIZE * GRADIENT_ACCUMULATION_STEPS）
    GRADIENT_ACCUMULATION_STEPS = 2  # 等效batch_size=16

    # 优化器参数
    OPTIMIZER = "adamw"
    LEARNING_RATE = 5e-4  # 最佳学习率（调参实验得出）
    WEIGHT_DECAY = 0.01
    BETAS = (0.9, 0.999)

    # 学习率调度
    LR_SCHEDULER = "cosine"  # "polynomial", "cosine", "step"
    LR_POWER = 0.9
    WARMUP_EPOCHS = 10
    WARMUP_LR = 1e-6
    MIN_LR = 1e-7

    # 损失函数配置
    # cd: combined (BCE+Dice); scd: smoothl1 (regression)
    LOSS_TYPE = "smoothl1"

    # 损失权重
    LOSS_WEIGHT_BCE = 0.5
    LOSS_WEIGHT_DICE = 0.5
    LOSS_WEIGHT_BOUNDARY = 0.1

    # Focal Loss参数（如果使用）
    FOCAL_ALPHA = 0.25
    FOCAL_GAMMA = 2.0

    # 类别权重（处理类别不平衡）
    USE_CLASS_WEIGHTS = True
    # LEVIR-CD中变化像素约占5-10%，设置权重平衡
    CLASS_WEIGHTS = [1.0, 4.0]  # [unchanged, changed] - 最佳权重（调参实验得出）

    # 混合精度训练
    USE_AMP = True

    # ==================== 数据增强配置 ====================
    USE_AUGMENTATION = True

    # 随机裁剪（从1024裁剪到256）
    RANDOM_CROP = True
    CROP_SIZE = 256

    # 几何增强
    AUG_HFLIP = True
    AUG_VFLIP = True
    AUG_ROTATE = True
    AUG_HFLIP_PROB = 0.5
    AUG_VFLIP_PROB = 0.5
    AUG_ROTATE_PROB = 0.5

    # 颜色增强（对两张图像同时应用）
    AUG_COLOR_JITTER = True
    AUG_BRIGHTNESS = 0.2
    AUG_CONTRAST = 0.2
    AUG_SATURATION = 0.2
    AUG_HUE = 0.1

    # 高斯噪声
    AUG_GAUSSIAN_NOISE = True
    AUG_NOISE_VAR_LIMIT = (10.0, 50.0)

    # ==================== 评估配置 ====================
    # 保存频率
    SAVE_FREQ = 10  # 每10个epoch保存一次
    VAL_FREQ = 1    # 每个epoch验证一次

    # 早停
    EARLY_STOPPING = False
    PATIENCE = 30  # 30个epoch不提升则停止

    # 评估指标
    EVAL_METRICS = ['F1', 'IoU', 'OA', 'Precision', 'Recall', 'Kappa']

    # 最佳模型选择指标
    BEST_METRIC = 'F1'  # 基于F1分数选择最佳模型

    # ==================== 可视化配置 ====================
    VIS_NUM_SAMPLES = 10
    VIS_SAVE_INTERVAL = 20

    # ==================== 设备配置 ====================
    DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
    SEED = 42

    # ==================== 调试配置 ====================
    DEBUG = False
    DEBUG_SAMPLES = 50
    USE_TENSORBOARD = True

    # ==================== 测试时增强 ====================
    TTA = False  # Test Time Augmentation

    @classmethod
    def display(cls):
        """打印配置信息"""
        print("=" * 60)
        print("SegFormer Change Detection Configuration")
        print("=" * 60)
        print(f"Project Root: {cls.PROJECT_ROOT}")
        print(f"Data Root: {cls.DATA_ROOT}")
        print(f"Model: {cls.MODEL_TYPE}")
        print(f"Image Size: {cls.IMAGE_SIZE}")
        print(f"Batch Size: {cls.BATCH_SIZE}")
        print(f"Effective Batch Size: {cls.BATCH_SIZE * cls.GRADIENT_ACCUMULATION_STEPS}")
        print(f"Epochs: {cls.NUM_EPOCHS}")
        print(f"Learning Rate: {cls.LEARNING_RATE}")
        print(f"Device: {cls.DEVICE}")
        print(f"Deep Supervision: {cls.DEEP_SUPERVISION}")
        print(f"Fusion Type: {cls.FUSION_TYPE}")
        print("=" * 60)


# 创建全局配置实例
cfg = Config()

if __name__ == '__main__':
    cfg.display()
